<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="en-us"><title>eLua platform interface - SPI</title>

<link rel="stylesheet" type="text/css" href="../style.css"></head>
<body style="background-color: rgb(255, 255, 255);">
<h3>Overview</h3>
<p>
This part of the platform interface groups functions related to the SPI interface(s) of the MCU.
</p>
<h3>Data structures and constants</h3>
<a name="modeval"><p><pre><code>// SPI mode
#define PLATFORM_SPI_MASTER                   1
#define PLATFORM_SPI_SLAVE                    0</code></pre></p></a>
<p>Constants used to specify the SPI mode (master or slave).</p>

<a name="selval"><p><pre><code>// SS values
#define PLATFORM_SPI_SELECT_ON                1
#define PLATFORM_SPI_SELECT_OFF               0</code></pre></p></a>
<p>Constants used to select/deselect the SPI SS pin (if applicable).</p>

<p><pre><code>typedef u32 spi_data_type;</code></pre></p>
<p>This is the type of a SPI data word, thus limiting the maximum size of a SPI data work to 32 bits (which should be enough for all practical purposes).</p>
<h3>Functions</h3>
<p><pre><code>int platform_spi_exists( unsigned id );</code></pre></p>
<p>Returns 1 if the platform has the hardware SPI specified as argument, 0 otherwise. Implemented in <i>src/common.c</i>, it uses the <b>NUM_SPI</b> macro that must be defined in the
platform's <b>platform_conf.h</b> file (see <a href="arch_overview.html#platforms">here</a> for details). For example:</p>
<p><code>#define NUM_SPI   1      <b>// The platform has 1 SPI interface</b></code></p>

<p><pre><code>u32 platform_spi_setup( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits );</code></pre></p>
<p>This function is used to initialize the parameters of the SPI interface.<br>
Arguments:
<ul>
  <li><b>id</b>: the ID of the SPI interface.</li>
  <li><b>mode</b>: SPI port mode (<b>PLATFORM_SPI_MASTER</b> or <b>PLATFORM_SPI_SLAVE</b>, see <a href="#modeval">here</a>).</li>
  <li><b>clock</b>: clock speed for the SPI interface in master mode.</li>
  <li><b>cpol</b>: clock polarity.</li>
  <li><b>cpha</b>: clock phase.</li>
  <li><b>databits</b>: length of the SPI data word in bits (usually 8, but configurable on some platforms).</li>
</ul></p>
<p>This function returns the actual clock set for the SPI interface. Depending on the hardware, this may have a different value than the <b>clock</b> argument.<br>
<font color="red"><b>NOTE</b>: currently, only master SPI mode is implemented in <b>eLua</b>.</font></p>

<p><pre><code>spi_data_type platform_spi_send_recv( unsigned id, spi_data_type data );</code></pre></p>
<p>Executes a SPI read/write cycle by sending the data received in argument <b>data</b> and returning the data read from the SPI bus.</p>

<p><pre><code>void platform_spi_select( unsigned id, int is_select );</code></pre></p>
<p>For platforms that have a dedicated SS (Slave Select) pin in master SPI mode that be controlled manually, this function should enable or disable this pin on the SPI interface identified
by <b>id</b> depending on the value of the <b>is_select</b> argument (either <b>PLATFORM_SPI_SELECT_ON</b> or <b>PLATFORM_SPI_SELECT_OFF</b>, see <a href="#selval">here</a>). If this 
functionality does not exist in hardware this function does nothing.</p>
</body></html>
